<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>数据结构（C） | Acy-学无止境</title><meta name="author" content="Acy"><meta name="copyright" content="Acy"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="首先声明：本篇文章仅仅是个人笔记记录与拓展，并非个人原创，主要参考了B站UP主TyranLucifer的数据结构教程 课程参考 UP主源代码 链表单链表1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构（C）">
<meta property="og:url" content="http://example.com/2022/05/10/struct_data/index.html">
<meta property="og:site_name" content="Acy-学无止境">
<meta property="og:description" content="首先声明：本篇文章仅仅是个人笔记记录与拓展，并非个人原创，主要参考了B站UP主TyranLucifer的数据结构教程 课程参考 UP主源代码 链表单链表1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/lcjyl/images/img/structdata.jpg">
<meta property="article:published_time" content="2022-05-10T04:51:04.130Z">
<meta property="article:modified_time" content="2022-05-11T17:04:17.496Z">
<meta property="article:author" content="Acy">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/lcjyl/images/img/structdata.jpg"><link rel="shortcut icon" href="/img/my_favicon.jpg"><link rel="canonical" href="http://example.com/2022/05/10/struct_data/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '数据结构（C）',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-05-12 01:04:17'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.1.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://avatars.githubusercontent.com/u/82205323?s=400&amp;u=3b0d8385b46a33a5401767ff455bf0e935801a41&amp;v=4" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">3</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">0</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">1</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/lcjyl/images/img/structdata.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Acy-学无止境</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">数据结构（C）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2022-05-10T04:51:04.130Z" title="Created 2022-05-10 12:51:04">2022-05-10</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2022-05-11T17:04:17.496Z" title="Updated 2022-05-12 01:04:17">2022-05-12</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="数据结构（C）"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\css\APlayer.min.css"><script src="\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\js\Meting.min.js"></script><p>首先声明：本篇文章仅仅是个人笔记记录与拓展，并非个人原创，主要参考了B站UP主TyranLucifer的数据结构教程</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1W64y1z7jh?spm_id_from=333.999.0.0">课程参考</a></p>
<p><a target="_blank" rel="noopener" href="https://tyrantlucifer.com/">UP主源代码</a></p>
<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> data;     <span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span> <span class="comment">//指针域</span></span><br><span class="line">&#125;Node;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 链表初始化</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return Node*</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Node* <span class="title function_">Create</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* L = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>; <span class="comment">//初始化为NULL</span></span><br><span class="line">    L-&gt;data = <span class="number">0</span>; <span class="comment">//开始节点数为0（不包括头结点）</span></span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 头插法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param L 表头</span></span><br><span class="line"><span class="comment"> * @param data 插入值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HeadInser</span><span class="params">(Node* L, <span class="type">int</span> data)</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* Y = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    Y-&gt;data = data;</span><br><span class="line">    Y-&gt;next = L-&gt;next;<span class="comment">//新的节点指向头结点指向的那一个节点</span></span><br><span class="line">    L-&gt;next = Y;  <span class="comment">//头结点指向新的节点</span></span><br><span class="line">    L-&gt;data++;<span class="comment">//头结点数增加</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 尾插法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param L 表头</span></span><br><span class="line"><span class="comment"> * @param data 插入值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TailInser</span><span class="params">(Node* L, <span class="type">int</span> data)</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* Y = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    Node* LY = L;</span><br><span class="line">    <span class="comment">//无论是否为空 都要实现的部分放外面可减少代码量</span></span><br><span class="line">    Y-&gt;data = data;</span><br><span class="line">    <span class="comment">//如果L为空</span></span><br><span class="line">    <span class="keyword">if</span> (!L)</span><br><span class="line">    &#123;</span><br><span class="line">        Y-&gt;next = L-&gt;next;<span class="comment">//新节点Y指向头结点指向的下一个</span></span><br><span class="line">        L-&gt;next = Y;<span class="comment">//头结点指向Y</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (L-&gt;next)<span class="comment">//如果不为空的时候找到最后一个节点</span></span><br><span class="line">        &#123;</span><br><span class="line">            L = L-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        Y-&gt;next = L-&gt;next;</span><br><span class="line">        L-&gt;next = Y;</span><br><span class="line">    &#125;</span><br><span class="line">    LY-&gt;data++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 打印链表L</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param L</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PrintList</span><span class="params">(Node* L)</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* Y = L;</span><br><span class="line">    Y = Y-&gt;next;<span class="comment">//不打印表头</span></span><br><span class="line">    <span class="keyword">while</span> (Y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d -&gt; &quot;</span>, Y-&gt;data);</span><br><span class="line">        Y = Y-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;NULL\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 查找链表中是否有对于值</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param L</span></span><br><span class="line"><span class="comment"> * @param data 需要查找值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">List_Find</span><span class="params">(Node* L, <span class="type">int</span> data)</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* Y = L-&gt;next;<span class="comment">//不查找表头</span></span><br><span class="line">    <span class="keyword">while</span> (Y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (Y-&gt;data == data)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;找到了：%d\n&quot;</span>, Y-&gt;data);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Y = Y-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;抱歉，链表中没有查询值\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 删除链表所以符合值得节点 若链表为空则删除头结点</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param L</span></span><br><span class="line"><span class="comment"> * @param data 需要删除的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">List_Delet</span><span class="params">(Node* L, <span class="type">int</span> data)</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* Y = L;</span><br><span class="line">    Node* f = L;</span><br><span class="line">    <span class="keyword">if</span> (Y-&gt;next == <span class="literal">NULL</span>)<span class="comment">//空链表</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">free</span>(Y);</span><br><span class="line">        Y = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (Y-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (Y-&gt;next-&gt;data == data)</span><br><span class="line">            &#123;</span><br><span class="line">                Node* P = Y-&gt;next;<span class="comment">//记住删除的位置</span></span><br><span class="line">                Y-&gt;next = Y-&gt;next-&gt;next;<span class="comment">//指向下下个结点</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;删除值为%d后的链表: &quot;</span>, P-&gt;data);</span><br><span class="line">                <span class="built_in">free</span>(P);</span><br><span class="line">                f-&gt;data--;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Y = Y-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;data--;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;没有找到需要删除的结点\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 销毁链表</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param L</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">List_Destroy</span><span class="params">(Node* LY)</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* n = LY-&gt;next;</span><br><span class="line">    Node* L = LY-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (L)</span><br><span class="line">    &#123;</span><br><span class="line">        L = L-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(n);</span><br><span class="line">        LY-&gt;data--;</span><br><span class="line">        n = L;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(LY);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* LY = Create();</span><br><span class="line"></span><br><span class="line">    HeadInser(LY, <span class="number">1</span>);</span><br><span class="line">    HeadInser(LY, <span class="number">2</span>);</span><br><span class="line">    HeadInser(LY, <span class="number">3</span>);</span><br><span class="line">    TailInser(LY, <span class="number">4</span>);</span><br><span class="line">    TailInser(LY, <span class="number">5</span>);</span><br><span class="line">    TailInser(LY, <span class="number">6</span>);</span><br><span class="line">    PrintList(LY);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;节点数为：%d\n&quot;</span>, LY-&gt;data);</span><br><span class="line">    List_Find(LY, <span class="number">0</span>);</span><br><span class="line">    List_Find(LY, <span class="number">1</span>);</span><br><span class="line">    List_Delet(LY, <span class="number">6</span>);</span><br><span class="line">    PrintList(LY);</span><br><span class="line">    List_Destroy(LY);</span><br><span class="line">    LY = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="单循环链表"><a href="#单循环链表" class="headerlink" title="单循环链表"></a>单循环链表</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;Node;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 来拿表初始化</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return Node*</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Node* <span class="title function_">InitList</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* L = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    L-&gt;data = <span class="number">0</span>;</span><br><span class="line">    L-&gt;next = L; <span class="comment">//指向自己构成循环</span></span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 头插法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param L 需要插入节点的链表</span></span><br><span class="line"><span class="comment"> * @param data 插入节点值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HeadInsert</span><span class="params">(Node* L, <span class="type">int</span> data)</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* node = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    node-&gt;data = data;</span><br><span class="line">    node-&gt;next = L-&gt;next;  <span class="comment">//指向第一个节点</span></span><br><span class="line">    L-&gt;next = node; <span class="comment">//头结点指向新的节点</span></span><br><span class="line">    L-&gt;data++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 尾插法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param L</span></span><br><span class="line"><span class="comment"> * @param data</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TailInsert</span><span class="params">(Node* L, <span class="type">int</span> data)</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* nl = L;</span><br><span class="line">    Node* node = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    node-&gt;data = data;</span><br><span class="line">    <span class="keyword">while</span> (nl-&gt;next != L)<span class="comment">//找到最后一个节点</span></span><br><span class="line">    &#123;</span><br><span class="line">        nl = nl-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    node-&gt;next = L;</span><br><span class="line">    nl-&gt;next = node;</span><br><span class="line">    L-&gt;data++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 打印链表</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param L</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PrintList</span><span class="params">(Node* L)</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* node = L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (node != L)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d-&gt;&quot;</span>, node-&gt;data);</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;NULL\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 删除data对应值得节点</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param L  检索的链表</span></span><br><span class="line"><span class="comment"> * @param data 删除第一个符合值得节点</span></span><br><span class="line"><span class="comment"> * @return int</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Delete</span><span class="params">(Node* L, <span class="type">int</span> data)</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* pre = L; <span class="comment">//记住删除节点的前一个节点</span></span><br><span class="line">    Node* node = L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (node != L)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;data == data)</span><br><span class="line">        &#123;</span><br><span class="line">            pre-&gt;next = node-&gt;next; <span class="comment">//需删除节点的前一个节点指向删除节点后一个节点</span></span><br><span class="line">            <span class="built_in">free</span>(node);</span><br><span class="line">            L-&gt;data--;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;删除首个值为%d的节点\n&quot;</span>, data);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = node;</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;删除节点失败&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DestroyList</span><span class="params">(Node* L)</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* n = L-&gt;next;</span><br><span class="line">    Node* LY = L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (L != LY)</span><br><span class="line">    &#123;</span><br><span class="line">        LY = LY-&gt;next; <span class="comment">//L指向下一个节点再删除</span></span><br><span class="line">        <span class="built_in">free</span>(n);</span><br><span class="line">        L-&gt;data--;</span><br><span class="line">        n = LY;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(L);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;链表销毁！！&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* L = InitList();</span><br><span class="line">    HeadInsert(L, <span class="number">3</span>);</span><br><span class="line">    HeadInsert(L, <span class="number">2</span>);</span><br><span class="line">    HeadInsert(L, <span class="number">1</span>);</span><br><span class="line">    TailInsert(L, <span class="number">4</span>);</span><br><span class="line">    TailInsert(L, <span class="number">5</span>);</span><br><span class="line">    TailInsert(L, <span class="number">6</span>);</span><br><span class="line">    PrintList(L);</span><br><span class="line">    Delete(L, <span class="number">6</span>);</span><br><span class="line">    PrintList(L);</span><br><span class="line">    DestroyList(L);</span><br><span class="line">    L = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> data; <span class="comment">//数据域(头结点用来计节点个数)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">pre</span>;</span> <span class="comment">//指向前一个的指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span> <span class="comment">//指向后一个的指针</span></span><br><span class="line">&#125;Node;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 初始化链表：建立头结点，并且将其返回</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return Node*</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Node* <span class="title function_">InitList</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* L = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    L-&gt;data = <span class="number">0</span>;</span><br><span class="line">    L-&gt;pre = <span class="literal">NULL</span>;</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 头插法：建立一个新节点，插入在原本链表的头结点和第一个节点之间</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param L    插入的链表</span></span><br><span class="line"><span class="comment"> * @param data 插入值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HeadInser</span><span class="params">(Node* L, <span class="type">int</span> data)</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* node = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    node-&gt;data = data; <span class="comment">//填充数据域</span></span><br><span class="line">    node-&gt;next = L-&gt;next; <span class="comment">//新的节点指向第一个节点（头结点的下一个）</span></span><br><span class="line">    node-&gt;pre = L; <span class="comment">//新节点的前一个指向头结点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果链表不止头结点</span></span><br><span class="line">    <span class="keyword">if</span> (L-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*这里注意到 L-&gt;next是指向旧的第一个节点的，先对旧的第一个节点的前</span></span><br><span class="line"><span class="comment">        * 进行了操作，然后在改变L-&gt;next指向新的第一个节点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        L-&gt;next-&gt;pre = node; <span class="comment">//原初的第一个节点的前指向新的第一个节点</span></span><br><span class="line">        L-&gt;next = node; <span class="comment">//头结点指向node，即新的第一个节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果链表只有头结点</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        L-&gt;next = node;</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;data++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 尾插法：新的节点插入到链表末尾</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param L 需要插入节点的链表</span></span><br><span class="line"><span class="comment"> * @param data  插入的节点的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TailInsert</span><span class="params">(Node* L, <span class="type">int</span> data)</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* node = L; <span class="comment">//对node指针操作，目的是不改动L指针</span></span><br><span class="line">    Node* nl = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    nl-&gt;data = data; <span class="comment">//填充数据</span></span><br><span class="line">    <span class="keyword">while</span> (node-&gt;next) <span class="comment">//node找到最后一个节点位置</span></span><br><span class="line">    &#123;</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    nl-&gt;next = node-&gt;next; <span class="comment">//新的节点指向最后一个节点的后</span></span><br><span class="line">    node-&gt;next = nl; <span class="comment">//旧的最后一个节点的后指向新的节点</span></span><br><span class="line">    nl-&gt;pre = node; <span class="comment">//新的前直接指向旧的最后一个节点</span></span><br><span class="line">    L-&gt;data++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 删除传入值得节点</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param L 删除节点的链表</span></span><br><span class="line"><span class="comment"> * @param data 删除的值</span></span><br><span class="line"><span class="comment"> * @return int 1：成功找到对应节点且删除  0：删除失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Delete</span><span class="params">(Node* L, <span class="type">int</span> data)</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* node = L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (node)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;data == data) <span class="comment">//如果节点值与插入值相同</span></span><br><span class="line">        &#123;</span><br><span class="line">            node-&gt;pre-&gt;next = node-&gt;next; <span class="comment">//删除节点的前一个节点的后指向删除节点的后一个</span></span><br><span class="line">            <span class="keyword">if</span> (node-&gt;next) <span class="comment">//如果删除节点不是最后一个节点</span></span><br><span class="line">            &#123;</span><br><span class="line">                node-&gt;next-&gt;pre = node-&gt;pre; <span class="comment">//删除节点的下一个的前指向删除节点的前一个节点</span></span><br><span class="line">            &#125;</span><br><span class="line">            L-&gt;data--;</span><br><span class="line">            <span class="built_in">free</span>(node);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">//匹配且删除成功</span></span><br><span class="line">        &#125;</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//删除值匹配失败</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 打印链表</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param L 需要打印的链表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PrintList</span><span class="params">(Node* L)</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* node = L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (node)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d-&gt;&quot;</span>, node-&gt;data);</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;NULL\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 销毁链表</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param L 需要销毁的链表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DestroyList</span><span class="params">(Node* L)</span></span><br><span class="line">&#123;</span><br><span class="line">    Node *n = L-&gt;next;</span><br><span class="line">    Node* LY = L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (LY)</span><br><span class="line">    &#123;</span><br><span class="line">        LY = LY-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(n);</span><br><span class="line">        L-&gt;data--;</span><br><span class="line">        n = LY;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(L);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* L = InitList(); <span class="comment">//建立链表</span></span><br><span class="line">    HeadInser(L, <span class="number">3</span>);</span><br><span class="line">    HeadInser(L, <span class="number">2</span>);</span><br><span class="line">    HeadInser(L, <span class="number">1</span>);</span><br><span class="line">    TailInsert(L, <span class="number">4</span>);</span><br><span class="line">    TailInsert(L, <span class="number">5</span>);</span><br><span class="line">    TailInsert(L, <span class="number">6</span>);</span><br><span class="line">    PrintList(L);</span><br><span class="line">    Delete(L, <span class="number">5</span>);</span><br><span class="line">    PrintList(L);</span><br><span class="line">    DestroyList(L);</span><br><span class="line">    L = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="双循环链表"><a href="#双循环链表" class="headerlink" title="双循环链表"></a>双循环链表</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> data; <span class="comment">//数据域(头结点用来计节点个数)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">pre</span>;</span> <span class="comment">//指向前一个的指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span> <span class="comment">//指向后一个的指针</span></span><br><span class="line">&#125;Node;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 初始化链表：建立头结点，并且将其返回</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return Node*</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Node* <span class="title function_">InitList</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* L = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    L-&gt;data = <span class="number">0</span>;</span><br><span class="line">    L-&gt;pre = L;</span><br><span class="line">    L-&gt;next = L;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 头插法：建立一个新节点，插入在原本链表的头结点和第一个节点之间</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param L    插入的链表</span></span><br><span class="line"><span class="comment"> * @param data 插入值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HeadInser</span><span class="params">(Node* L, <span class="type">int</span> data)</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* node = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    node-&gt;data = data; <span class="comment">//填充数据域</span></span><br><span class="line">    node-&gt;next = L-&gt;next; <span class="comment">//新的节点指向第一个节点（头结点的下一个）</span></span><br><span class="line">    node-&gt;pre = L; <span class="comment">//新节点的前一个指向头结点</span></span><br><span class="line">    L-&gt;next-&gt;pre = node; <span class="comment">//原本第一个节点的前指向node（这里不用考虑是否只是一个包含头结点的链表，因为它是循环的。</span></span><br><span class="line">                         <span class="comment">//假设只有头结点，那么它的下一个的前还是它自己，并不会指向不明地方）</span></span><br><span class="line">    L-&gt;next = node; <span class="comment">//头结点的下一个指向新节点</span></span><br><span class="line">    L-&gt;data++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 尾插法：新的节点插入到链表末尾</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param L 需要插入节点的链表</span></span><br><span class="line"><span class="comment"> * @param data  插入的节点的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TailInsert</span><span class="params">(Node* L, <span class="type">int</span> data)</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* node = L; <span class="comment">//对node指针操作，目的是不改动L指针</span></span><br><span class="line">    Node* nl = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    nl-&gt;data = data; <span class="comment">//填充数据</span></span><br><span class="line">    <span class="keyword">while</span> (node-&gt;next != L) <span class="comment">//node找到最后一个节点位置</span></span><br><span class="line">    &#123;</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    nl-&gt;pre = node; <span class="comment">//新节点的前指向旧的最后一个节点</span></span><br><span class="line">    nl-&gt;next = L; <span class="comment">//新的节点的后指向头结点</span></span><br><span class="line">    L-&gt;pre = nl; <span class="comment">//头结点的前指向新节点</span></span><br><span class="line">    node-&gt;next = nl; <span class="comment">//旧的最后一个节点指向新插入末尾的节点</span></span><br><span class="line">    nl-&gt;pre = node; <span class="comment">//新的前直接指向旧的最后一个节点</span></span><br><span class="line">    L-&gt;data++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 删除传入值得节点</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param L 删除节点的链表</span></span><br><span class="line"><span class="comment"> * @param data 删除的值</span></span><br><span class="line"><span class="comment"> * @return int 1：成功找到对应节点且删除  0：删除失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Delete</span><span class="params">(Node* L, <span class="type">int</span> data)</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* node = L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (node != L)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;data == data) <span class="comment">//如果节点值与插入值相同</span></span><br><span class="line">        &#123;</span><br><span class="line">            node-&gt;pre-&gt;next = node-&gt;next; <span class="comment">//删除节点前一个节点的后指向删除节点的后一个节点</span></span><br><span class="line">            node-&gt;next-&gt;pre = node-&gt;pre; <span class="comment">//删除节点的有一个节点的前指向删除节点的前一个节点</span></span><br><span class="line">            L-&gt;data--;</span><br><span class="line">            <span class="built_in">free</span>(node);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">//匹配且删除成功</span></span><br><span class="line">        &#125;</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//删除值匹配失败</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 打印链表</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param L 需要打印的链表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PrintList</span><span class="params">(Node* L)</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* node = L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (node != L)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d-&gt;&quot;</span>, node-&gt;data);</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;NULL\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 销毁链表</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param L 需要销毁的链表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DestroyList</span><span class="params">(Node* L)</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* LY = L-&gt;next;</span><br><span class="line">    Node* n = L-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (L != LY)</span><br><span class="line">    &#123;</span><br><span class="line">        LY = LY-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(n);</span><br><span class="line">        L-&gt;data--;</span><br><span class="line">        n = LY;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(L);<span class="comment">//销毁表头</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* L = InitList(); <span class="comment">//建立链表</span></span><br><span class="line">    HeadInser(L, <span class="number">3</span>);</span><br><span class="line">    HeadInser(L, <span class="number">2</span>);</span><br><span class="line">    HeadInser(L, <span class="number">1</span>);</span><br><span class="line">    TailInsert(L, <span class="number">4</span>);</span><br><span class="line">    TailInsert(L, <span class="number">5</span>);</span><br><span class="line">    TailInsert(L, <span class="number">6</span>);</span><br><span class="line">    PrintList(L);</span><br><span class="line">    Delete(L, <span class="number">5</span>);</span><br><span class="line">    PrintList(L);</span><br><span class="line">    DestroyList(L);</span><br><span class="line">    L = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;Node;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 栈初始化</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @return Node* </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Node *<span class="title function_">InitStack</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Node *L = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    L-&gt;data = <span class="number">0</span>;</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 压栈，出去头结点外，将值压入栈中，类似单链表头插法</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param L </span></span><br><span class="line"><span class="comment"> * @param data </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Push</span><span class="params">(Node* L, <span class="type">int</span> data)</span></span><br><span class="line">&#123;</span><br><span class="line">    Node *node = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    node-&gt;data = data;</span><br><span class="line">    node-&gt;next = L-&gt;next;</span><br><span class="line">    L-&gt;next = node;</span><br><span class="line">    L-&gt;data++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 弹出栈顶</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param L </span></span><br><span class="line"><span class="comment"> * @return int 返回站定制 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Pop</span><span class="params">(Node *L)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(L-&gt;data == <span class="number">0</span>) <span class="comment">//如果栈空</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;栈为空\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        Node *node = L-&gt;next;</span><br><span class="line">        <span class="type">int</span> data = node-&gt;data;</span><br><span class="line">        L-&gt;next = node-&gt;next; <span class="comment">//类似于单链表中的删除某个节点</span></span><br><span class="line">        <span class="built_in">free</span>(node);</span><br><span class="line">        L-&gt;data--;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 栈是否为空</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param L </span></span><br><span class="line"><span class="comment"> * @return int 0：非空 1：空</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">IsEmpty</span><span class="params">(Node *L)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(L-&gt;data == <span class="number">0</span> || L-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 清空栈（并没销毁，保留了头结点,当然也可以连头结点都删，只不过下述没有给出对应代码）</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ClearStack</span><span class="params">(Node *<span class="built_in">stack</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Node *node = <span class="built_in">stack</span>-&gt;next;</span><br><span class="line">    Node *LY = <span class="built_in">stack</span>-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(LY)</span><br><span class="line">    &#123;</span><br><span class="line">        LY = LY-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(node);</span><br><span class="line">        <span class="built_in">stack</span>-&gt;data--; </span><br><span class="line">        node = LY;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 打印栈中元素</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param stack </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PrintStack</span><span class="params">(Node *<span class="built_in">stack</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Node *node = <span class="built_in">stack</span>-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(node)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d-&gt;&quot;</span>, node-&gt;data);</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;NULL\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Node *<span class="built_in">stack</span> = InitStack(); <span class="comment">//创建栈</span></span><br><span class="line">    Push(<span class="built_in">stack</span>, <span class="number">5</span>);</span><br><span class="line">    Push(<span class="built_in">stack</span>, <span class="number">4</span>);</span><br><span class="line">    Push(<span class="built_in">stack</span>, <span class="number">3</span>);</span><br><span class="line">    Push(<span class="built_in">stack</span>, <span class="number">2</span>);</span><br><span class="line">    Push(<span class="built_in">stack</span>, <span class="number">1</span>);</span><br><span class="line">    PrintStack(<span class="built_in">stack</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;栈顶值为:%d\n&quot;</span>, Pop(<span class="built_in">stack</span>));</span><br><span class="line">    PrintStack(<span class="built_in">stack</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;清空前栈的长度：%d\n&quot;</span>, <span class="built_in">stack</span>-&gt;data);</span><br><span class="line">    ClearStack(<span class="built_in">stack</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;清空后栈的长度：%d\n&quot;</span>,<span class="built_in">stack</span>-&gt;data);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     仍然可以对stack使用，并未销毁表头        </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><h2 id="非循环队列"><a href="#非循环队列" class="headerlink" title="非循环队列"></a>非循环队列</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 队列是一种特殊的线性表，特殊之处在于它只允许在表的前端（front）进行删除操作，</span></span><br><span class="line"><span class="comment">  而在表的后端（rear）进行插入操作，和栈一样，队列是一种操作受限制的线性表。进行插入操作的端称为队尾，进行删除操作的端称为队头。队列中没有元素时，称为空队列。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">pre</span>;</span></span><br><span class="line">&#125;Node;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 队的初始化</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return Node*</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Node* <span class="title function_">InitQueue</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* Q = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    Q-&gt;data = <span class="number">0</span>;</span><br><span class="line">    Q-&gt;pre = Q;</span><br><span class="line">    Q-&gt;next = Q;</span><br><span class="line">    <span class="keyword">return</span> Q;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 入队操作</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param Q    需要插入值的队</span></span><br><span class="line"><span class="comment"> * @param data 插入值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">EnQueue</span><span class="params">(Node* Q, <span class="type">int</span> data)</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* node = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    node-&gt;data = data;</span><br><span class="line">    node-&gt;next = Q; <span class="comment">//新节点的后指向头结点</span></span><br><span class="line">    node-&gt;pre = Q-&gt;pre; <span class="comment">//新节点的前指向最后一个节点</span></span><br><span class="line">    Q-&gt;pre-&gt;next = node; <span class="comment">//旧的最后一个节点的后指向新的节点</span></span><br><span class="line">    Q-&gt;pre = node; <span class="comment">//头结点的前指向最后一个节点</span></span><br><span class="line">    Q-&gt;data++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 判断是否为空队</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param Q 判断的队列</span></span><br><span class="line"><span class="comment"> * @return int 1：空       0：非空</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">IsEmpty</span><span class="params">(Node* Q)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (Q-&gt;data == <span class="number">0</span> || Q-&gt;next == Q)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 出队操作</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param Q</span></span><br><span class="line"><span class="comment"> * @return int 返回出队值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">DeQueue</span><span class="params">(Node* Q)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (IsEmpty(Q))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error,队空!!!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        Node* LY = Q;</span><br><span class="line">        Node* node = Q-&gt;next;</span><br><span class="line">        Q-&gt;next = Q-&gt;next-&gt;next; <span class="comment">//先改变头结点的next指到第二个节点</span></span><br><span class="line">        Q-&gt;next-&gt;pre = Q; <span class="comment">//操作第二个节点的前指向头结点（相当于沙成黏糊了）</span></span><br><span class="line">        <span class="type">int</span> data = node-&gt;data;</span><br><span class="line">        <span class="built_in">free</span>(node);</span><br><span class="line">        LY-&gt;data--; <span class="comment">//出队后队长自减</span></span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 销毁队</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param Q</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DestroyQueue</span><span class="params">(Node* Q)</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* node = Q;</span><br><span class="line">    Node* LY = Q;</span><br><span class="line">    <span class="keyword">while</span> (Q != LY)</span><br><span class="line">    &#123;</span><br><span class="line">        Q = Q-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(node);</span><br><span class="line">        node = Q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">PrintQueue</span><span class="params">(Node* Q)</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* node = Q-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (node != Q)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d-&gt;&quot;</span>, node-&gt;data);</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;NULL\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Node* Q = InitQueue();</span><br><span class="line">    EnQueue(Q, <span class="number">5</span>);</span><br><span class="line">    EnQueue(Q, <span class="number">4</span>);</span><br><span class="line">    EnQueue(Q, <span class="number">3</span>);</span><br><span class="line">    EnQueue(Q, <span class="number">2</span>);</span><br><span class="line">    EnQueue(Q, <span class="number">1</span>);</span><br><span class="line">    PrintQueue(Q);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;队长: %d\n&quot;</span>, Q-&gt;data);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;出队：%d\n&quot;</span>, DeQueue(Q));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;出队：%d\n&quot;</span>, DeQueue(Q));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;出队：%d\n&quot;</span>, DeQueue(Q));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;队长: %d\n&quot;</span>, Q-&gt;data);</span><br><span class="line">    PrintQueue(Q);</span><br><span class="line">    DestroyQueue(Q);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 循环队列就是将队列存储空间的最后一个位置绕到第一个位置</span></span><br><span class="line"><span class="comment">* ，形成逻辑上的环状空间，供队列循环使用。在循环队列结构中</span></span><br><span class="line"><span class="comment">* ，当存储空间的最后一个位置已被使用而再要进入队运算时，</span></span><br><span class="line"><span class="comment">* 只需要存储空间的第一个位置空闲，便可将元素加入到第一个位置，</span></span><br><span class="line"><span class="comment">* 即将存储空间的第一个位置作为队尾。 [1]  循环队列可以更简单防止伪溢出的发生，但队列大小是固定的。</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Queue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> front; <span class="comment">//队首位置</span></span><br><span class="line">    <span class="type">int</span> rear; <span class="comment">//队尾位置</span></span><br><span class="line">    <span class="type">int</span> data[MAXSIZE];</span><br><span class="line">&#125;Queue;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 循环队初始化</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @return Queue* </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Queue* <span class="title function_">InitQueue</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Queue *Q = (Queue*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Queue));</span><br><span class="line">    Q-&gt;front = <span class="number">0</span>;</span><br><span class="line">    Q-&gt;rear = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> Q;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 判断队是否满了</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param Q </span></span><br><span class="line"><span class="comment"> * @return int 0：没满 1：满了</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">IsFull</span><span class="params">(Queue *Q)</span></span><br><span class="line">&#123;   </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    若满了尾巴+1对最大长度取余永远等于头</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span>((Q-&gt;rear + <span class="number">1</span>) % MAXSIZE == Q-&gt;front)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 是否空队</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param Q </span></span><br><span class="line"><span class="comment"> * @return int 0：否 1：是</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">IsEmpty</span><span class="params">(Queue *Q)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q-&gt;front == Q-&gt;rear)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 获取队长</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param Q </span></span><br><span class="line"><span class="comment"> * @return int  返回队长值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">GetQueLen</span><span class="params">(Queue *Q)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    若队尾在的位置大于队首 则MAXSIZE不起作用，即队长为队尾减去队首</span></span><br><span class="line"><span class="comment">    反之，队尾减去队首所得值得绝对值为空的个数，加上MAXSIZE即为队长</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">int</span> len = (Q-&gt;rear - Q-&gt;front + MAXSIZE) % MAXSIZE;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 入队（最后一个位置留空）</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param Q </span></span><br><span class="line"><span class="comment"> * @param data 入队的值 </span></span><br><span class="line"><span class="comment"> * @return int 1：成功 0：队已满</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">EnQueue</span><span class="params">(Queue *Q, <span class="type">int</span> data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(IsFull(Q))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;抱歉，队已满。&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        Q-&gt;data[Q-&gt;rear] = data;</span><br><span class="line">        Q-&gt;rear = (Q-&gt;rear + <span class="number">1</span>) % MAXSIZE;<span class="comment">//若刚刚已经指向了最后一个位置下标，再往后则跳到第一个位置下标</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 删除队首</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param Q </span></span><br><span class="line"><span class="comment"> * @return int 返回队首值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">DeQueue</span><span class="params">(Queue *Q)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(IsEmpty(Q))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;队已空\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> data = Q-&gt;data[Q-&gt;front];</span><br><span class="line">        Q-&gt;front = (Q-&gt;front + <span class="number">1</span>) % MAXSIZE; <span class="comment">//同上理</span></span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 打印列表</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param Q </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PrintQueue</span><span class="params">(Queue *Q)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> len = GetQueLen(Q);</span><br><span class="line">    <span class="type">int</span> index = Q-&gt;front;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; len; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d-&gt;&quot;</span>, Q-&gt;data[index]);</span><br><span class="line">        index = (index + <span class="number">1</span>) % MAXSIZE; <span class="comment">//若超出队尾则又循环到队头</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;NLUU\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Queue *Q = InitQueue();</span><br><span class="line">    EnQueue(Q, <span class="number">4</span>);</span><br><span class="line">    EnQueue(Q, <span class="number">3</span>);</span><br><span class="line">    EnQueue(Q, <span class="number">2</span>);</span><br><span class="line">    EnQueue(Q, <span class="number">1</span>);</span><br><span class="line">    PrintQueue(Q);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;队长:%d\n&quot;</span>,GetQueLen(Q));</span><br><span class="line">    EnQueue(Q, <span class="number">5</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;删除队首：%d\n&quot;</span>, DeQueue(Q));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;删除队首：%d\n&quot;</span>, DeQueue(Q));</span><br><span class="line">    PrintQueue(Q);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="字符串匹配"><a href="#字符串匹配" class="headerlink" title="字符串匹配"></a>字符串匹配</h1><h2 id="直接匹配"><a href="#直接匹配" class="headerlink" title="直接匹配"></a>直接匹配</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span>* data;</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">&#125;String;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 字符串初始化</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return String*</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">String* <span class="title function_">InitString</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    String* s = (String*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(String));</span><br><span class="line">    s-&gt;data = <span class="literal">NULL</span>; <span class="comment">//初始化为空指针</span></span><br><span class="line">    s-&gt;len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 给字符串赋值</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param s 需要赋值的字符串</span></span><br><span class="line"><span class="comment"> * @param data 赋值的字符串</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">StringAssign</span><span class="params">(String* s, <span class="type">char</span>* data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (s-&gt;data) <span class="comment">//若本身不为空释放掉在重新开辟</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">free</span>(s-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span>* temp = data;</span><br><span class="line">    <span class="keyword">while</span> (*temp) <span class="comment">//获取data 长度</span></span><br><span class="line">    &#123;</span><br><span class="line">        len++;</span><br><span class="line">        temp++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        s-&gt;data = <span class="literal">NULL</span>;</span><br><span class="line">        s-&gt;len = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        temp = data;</span><br><span class="line">        s-&gt;len = len;</span><br><span class="line">        s-&gt;data = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>) * (len + <span class="number">1</span>));<span class="comment">//还有个空字符</span></span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++, temp++)</span><br><span class="line">        &#123;</span><br><span class="line">            s-&gt;data[i] = *temp;</span><br><span class="line">        &#125;</span><br><span class="line">        s-&gt;data[len] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">//字符串末尾记得加上&#x27;\0&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 字符串输出</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param s 所需要输出的字符串</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PrintString</span><span class="params">(String* s)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; s-&gt;len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(i == <span class="number">0</span> ? <span class="string">&quot;%c&quot;</span> : <span class="string">&quot;-&gt;%c&quot;</span>, s-&gt;data[i]);<span class="comment">//第一个字符则直接输出，其它字符在前面加上-&gt;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 强制匹配字符串</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param master 主字符串</span></span><br><span class="line"><span class="comment"> * @param sub 子字符串</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ForceMatch</span><span class="params">(String* master, String* sub)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; master-&gt;len &amp;&amp; j &lt; sub-&gt;len)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (master-&gt;data[i] == sub-&gt;data[j])</span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            i = i - j + <span class="number">1</span>; <span class="comment">//相当于每次匹配失败主字符串往后挪一个</span></span><br><span class="line">            j = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j == sub-&gt;len)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;匹配成功!!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;匹配失败\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 下面使用了命令行参数传参</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    String* s1 = InitString();</span><br><span class="line">    String* s2 = InitString();</span><br><span class="line">    StringAssign(s1, argv[<span class="number">1</span>]);</span><br><span class="line">    StringAssign(s2, argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="comment">// 不适用命令行参数</span></span><br><span class="line">    <span class="comment">//StringAssign(s1, &quot;abcd&quot;);</span></span><br><span class="line">    <span class="comment">//StringAssign(s2, &quot;abcde&quot;);</span></span><br><span class="line">    PrintString(s1);</span><br><span class="line">    PrintString(s2);</span><br><span class="line">    ForceMatch(s1, s2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="KMP算法实现"><a href="#KMP算法实现" class="headerlink" title="KMP算法实现"></a>KMP算法实现</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/woshidenghaitao/article/details/89439921">KMP算法参考链接</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 主要思路为：前缀后缀 例如给定字符串为ABCDABD              0 0 0 0 1 2 1  前缀后缀：例如第一个A前面有一个A故为1  后面AB 对应前面AB故第二个B为2 最后一个D同理前缀后缀一个D 故为1</span></span><br><span class="line"><span class="comment">* 它的next数组（将前缀后缀往右移动一个单位，且首个变为-1）为-1 0 0 0 0 1 2</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span>* data;</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">&#125;String;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 字符串初始化</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return String*</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">String* <span class="title function_">InitString</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    String* s = (String*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(String));</span><br><span class="line">    s-&gt;data = <span class="literal">NULL</span>; <span class="comment">//初始化为空指针</span></span><br><span class="line">    s-&gt;len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 给字符串赋值</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param s 需要赋值的字符串</span></span><br><span class="line"><span class="comment"> * @param data 赋值的字符串</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">StringAssign</span><span class="params">(String* s, <span class="type">char</span>* data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (s-&gt;data) <span class="comment">//若本身不为空释放掉在重新开辟</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">free</span>(s-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span>* temp = data;</span><br><span class="line">    <span class="keyword">while</span> (*temp) <span class="comment">//获取data 长度</span></span><br><span class="line">    &#123;</span><br><span class="line">        len++;</span><br><span class="line">        temp++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        s-&gt;data = <span class="literal">NULL</span>;</span><br><span class="line">        s-&gt;len = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        temp = data;</span><br><span class="line">        s-&gt;len = len;</span><br><span class="line">        s-&gt;data = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>) * (len + <span class="number">1</span>));<span class="comment">//还有个空字符</span></span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++, temp++)</span><br><span class="line">        &#123;</span><br><span class="line">            s-&gt;data[i] = *temp;</span><br><span class="line">        &#125;</span><br><span class="line">        s-&gt;data[len] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">//字符串末尾记得加上&#x27;\0&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 字符串输出</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param s 所需要输出的字符串</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PrintString</span><span class="params">(String* s)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; s-&gt;len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c  &quot;</span>, s-&gt;data[i]);<span class="comment">//第一个字符则直接输出，其它字符在前面加上-&gt;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 获取字符串的下个数组</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param s</span></span><br><span class="line"><span class="comment"> * @return int*</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span>* <span class="title function_">GetNext</span><span class="params">(String* s)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span>* next = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * s-&gt;len);</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">-1</span>;</span><br><span class="line">    next[j] = k;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; s-&gt;len - <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">-1</span> || s-&gt;data[j] == s-&gt;data[k]) <span class="comment">//若字符匹配或者k为-1</span></span><br><span class="line">        &#123;</span><br><span class="line">            k++;</span><br><span class="line">            j++;</span><br><span class="line">            <span class="comment">//优化前的kmp </span></span><br><span class="line">            <span class="comment">//next[j] = k;</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//优化后的kmp</span></span><br><span class="line">            <span class="keyword">if</span> (s-&gt;data[j] != s-&gt;data[k])</span><br><span class="line">            &#123;</span><br><span class="line">                next[j] = k;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">//形如abab时候 ab对不上时候后面也是ab铁定也是对不上，需要直接往后挪</span></span><br><span class="line">            &#123;</span><br><span class="line">                next[j] = next[k];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            k = next[k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param next</span></span><br><span class="line"><span class="comment"> * @param len</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PrintNext</span><span class="params">(<span class="type">int</span>* next, <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d  &quot;</span>, next[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief KMP算法匹配</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param master 主字符串</span></span><br><span class="line"><span class="comment"> * @param sub    匹配的字符串</span></span><br><span class="line"><span class="comment"> * @param next   主字符串的next数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">KmpMatch</span><span class="params">(String* master, String* sub, <span class="type">int</span>* next)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; master-&gt;len &amp;&amp; j &lt; sub-&gt;len)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">-1</span> || master-&gt;data[i] == sub-&gt;data[j])</span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            j = next[j]; <span class="comment">//字符不匹配时候直接从下一个长度更短的前缀后缀 </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j == sub-&gt;len)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;匹配成功!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;匹配失败!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    String* s1 = InitString();</span><br><span class="line">    String* s2 = InitString();</span><br><span class="line">    <span class="comment">// StringAssign(s1,argv[1]);</span></span><br><span class="line">    <span class="comment">// StringAssign(s2,argv[2]);</span></span><br><span class="line">    StringAssign(s1, <span class="string">&quot;absabdaabdabss&quot;</span>);</span><br><span class="line">    StringAssign(s2, <span class="string">&quot;abdabs&quot;</span>);</span><br><span class="line">    PrintString(s1);</span><br><span class="line">    PrintString(s2);</span><br><span class="line">    <span class="type">int</span>* next = GetNext(s1); <span class="comment">//获取s1的next数组</span></span><br><span class="line">    PrintNext(next, s1-&gt;len);</span><br><span class="line">    KmpMatch(s1, s2, next);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="二叉树的创建"><a href="#二叉树的创建" class="headerlink" title="二叉树的创建"></a>二叉树的创建</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//二叉树创建、遍历、销毁、深度</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">lchild</span>;</span> <span class="comment">//左孩子</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">rchild</span>;</span> <span class="comment">//右孩子</span></span><br><span class="line">&#125;TreeNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 二叉树的创建(先序遍历创建)，注意：用二级指针原因是修改了一级指针的内容</span></span><br><span class="line"><span class="comment"> *        根左右的创建方式</span></span><br><span class="line"><span class="comment"> * @param T 二叉树</span></span><br><span class="line"><span class="comment"> * @param data 用于建立二叉树的字符串</span></span><br><span class="line"><span class="comment"> * @param index 用于在递归中记录当前第N个字符</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateTree</span><span class="params">(TreeNode **T, <span class="type">char</span> *data, <span class="type">int</span> *index)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    ch = data[*index];</span><br><span class="line">    *index += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(ch == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        *T = <span class="literal">NULL</span>; <span class="comment">//若为#则为空节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        *T = (TreeNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(TreeNode));</span><br><span class="line">        (*T)-&gt;data = ch;</span><br><span class="line">        <span class="comment">//根据递归思路知道：它会先创建左边的遇到#然后递归回来在创建右边的</span></span><br><span class="line">        CreateTree(&amp;((*T)-&gt;lchild), data, index); <span class="comment">//创建左子树</span></span><br><span class="line">        CreateTree(&amp;((*T)-&gt;rchild), data, index); <span class="comment">//创建右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 先序遍历 简言之：先办事-&gt;处理左孩子-&gt;处理右孩子 中-&gt;左-&gt;右</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param T </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PreOrder</span><span class="params">(TreeNode *T)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(T == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, T-&gt;data); <span class="comment">//先打印</span></span><br><span class="line">        PreOrder(T-&gt;lchild); <span class="comment">//在打印左孩子</span></span><br><span class="line">        PreOrder(T-&gt;rchild); <span class="comment">//最后打印右孩子</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 中序遍历：简言之：先处理左孩子-&gt;办事-&gt;处理右孩子 左-&gt;中-&gt;右</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param T </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InOrder</span><span class="params">(TreeNode *T)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(T == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        InOrder(T-&gt;lchild); <span class="comment">//打印左孩子</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, T-&gt;data);</span><br><span class="line">        InOrder(T-&gt;rchild); <span class="comment">//最后打印右孩子</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 后续遍历：简言之：先处理左孩子-&gt;右孩子-&gt;办事  左-&gt;右-&gt;中</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param T </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PostOrder</span><span class="params">(TreeNode *T)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(T == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        PreOrder(T-&gt;lchild); <span class="comment">//打印左孩子</span></span><br><span class="line">        PreOrder(T-&gt;rchild); <span class="comment">//最后打印右孩子</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, T-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 后续遍历销毁二叉树：先删除左端然后右端最后根节点</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param T </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DestroyTree</span><span class="params">(TreeNode* T)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(T == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;# &quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    DestroyTree(T-&gt;lchild);</span><br><span class="line">    DestroyTree(T-&gt;rchild);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, T-&gt;data);</span><br><span class="line">    <span class="built_in">free</span>(T);</span><br><span class="line">    T = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 求树的深度（最大值）</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param T </span></span><br><span class="line"><span class="comment"> * @return int </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">TreeDepth</span><span class="params">(TreeNode *T)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(T != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        从左到右，找到最左，左中判断右是否还有更深的树</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">int</span> left = TreeDepth(T-&gt;lchild); <span class="comment">//先找到最左的节点然后往回跳，且执行那层递归的右若为空则可直接往回跳（因为那个已经是最左的节点，最深的地方）</span></span><br><span class="line">        <span class="type">int</span> right = TreeDepth(T-&gt;rchild);<span class="comment">//同上理</span></span><br><span class="line">        <span class="keyword">return</span> left &gt; right ? left + <span class="number">1</span> : right + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    TreeNode *T;</span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//修改一级指针传其地址上述用二级指针接收，传第一个命令行参数的字符串</span></span><br><span class="line">    <span class="comment">// CreateTree(&amp;T, argv[1], &amp;index); </span></span><br><span class="line">    <span class="comment">// char *s = &quot;AB##C##&quot;; //根A 左B 右C</span></span><br><span class="line">    <span class="comment">// char *s = &quot;ABC###D#E##&quot;; //根A 左B 右C</span></span><br><span class="line">    <span class="type">char</span> *s = <span class="string">&quot;ABC##D#E##F##&quot;</span>;</span><br><span class="line">    CreateTree(&amp;T, s, &amp;index);</span><br><span class="line">    PreOrder(T);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    InOrder(T);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    PostOrder(T);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;二叉树销毁如下:\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;树的最大深度:%d\n&quot;</span>,TreeDepth(T));</span><br><span class="line">    DestroyTree(T);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二叉树的层次遍历"><a href="#二叉树的层次遍历" class="headerlink" title="二叉树的层次遍历"></a>二叉树的层次遍历</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//层次遍历：通过队先进先出来实现</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">lchild</span>;</span> <span class="comment">//左孩子</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">rchild</span>;</span> <span class="comment">//右孩子</span></span><br><span class="line">&#125;TreeNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 用于层次遍历的队</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QueueNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    TreeNode *data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">QueueNode</span>* <span class="title">pre</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">QueueNode</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;QueueNode;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 二叉树的创建，注意：用二级指针原因是修改了一级指针的内容</span></span><br><span class="line"><span class="comment"> *        根左右的创建方式</span></span><br><span class="line"><span class="comment"> * @param T 二叉树</span></span><br><span class="line"><span class="comment"> * @param data 用于建立二叉树的字符串</span></span><br><span class="line"><span class="comment"> * @param index 用于在递归中记录当前第N个字符</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateTree</span><span class="params">(TreeNode **T, <span class="type">char</span> *data, <span class="type">int</span> *index)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    ch = data[*index];</span><br><span class="line">    *index += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(ch == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        *T = <span class="literal">NULL</span>; <span class="comment">//若为#则为空节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        *T = (TreeNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(TreeNode));</span><br><span class="line">        (*T)-&gt;data = ch;</span><br><span class="line">        <span class="comment">//根据递归思路知道：它会先创建左边的遇到#然后递归回来在创建右边的</span></span><br><span class="line">        CreateTree(&amp;((*T)-&gt;lchild), data, index); <span class="comment">//创建左子树</span></span><br><span class="line">        CreateTree(&amp;((*T)-&gt;rchild), data, index); <span class="comment">//创建右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 先序遍历 简言之：先办事-&gt;处理左孩子-&gt;处理右孩子 中-&gt;左-&gt;右</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param T </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PreOrder</span><span class="params">(TreeNode *T)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(T == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, T-&gt;data); <span class="comment">//先打印</span></span><br><span class="line">        PreOrder(T-&gt;lchild); <span class="comment">//在打印左孩子</span></span><br><span class="line">        PreOrder(T-&gt;rchild); <span class="comment">//最后打印右孩子</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 队的初始化</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @return QueueNode* </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">QueueNode* <span class="title function_">InitQueue</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    QueueNode *Q = (QueueNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QueueNode));</span><br><span class="line">    Q-&gt;data = <span class="literal">NULL</span>;</span><br><span class="line">    Q-&gt;next = Q;</span><br><span class="line">    Q-&gt;pre = Q;</span><br><span class="line">    <span class="keyword">return</span> Q;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 入队</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param data 入队的树</span></span><br><span class="line"><span class="comment"> * @param Q    队列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">EnQueue</span><span class="params">(TreeNode *data, QueueNode *Q)</span></span><br><span class="line">&#123;</span><br><span class="line">    QueueNode *node = (QueueNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QueueNode));</span><br><span class="line">    node-&gt;data = data;</span><br><span class="line">    node-&gt;pre = Q-&gt;pre; <span class="comment">//新的节点前指向旧的最后一个</span></span><br><span class="line">    node-&gt;next = Q; </span><br><span class="line">    Q-&gt;pre-&gt;next =  node;<span class="comment">//队头结点的前的next就是之前最后一个，它的next指向新的node成了倒数第二个</span></span><br><span class="line">    Q-&gt;pre = node; <span class="comment">//队的前重新指向新的最后一个 也就是node</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 队是否为空</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param Q </span></span><br><span class="line"><span class="comment"> * @return int 0：非空 1：空</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">IsEmpty</span><span class="params">(QueueNode *Q)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q-&gt;next == Q)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 删除队中元素：即第一个节点</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param Q </span></span><br><span class="line"><span class="comment"> * @return QueueNode* </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">QueueNode *<span class="title function_">DeQueue</span><span class="params">(QueueNode *Q)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(IsEmpty(Q))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        QueueNode *node = Q-&gt;next;</span><br><span class="line">        Q-&gt;next-&gt;next-&gt;pre = Q; <span class="comment">//第二个节点前指向头结点</span></span><br><span class="line">        Q-&gt;next = Q-&gt;next-&gt;next; <span class="comment">//头结点指向第二个节点</span></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 层次遍历 </span></span><br><span class="line"><span class="comment"> *        先将根节点入队，然后若该根节点非空则进入while循环</span></span><br><span class="line"><span class="comment"> *        首先另其出队且输出，然后判断其左孩子是否空若不空入队，右同样</span></span><br><span class="line"><span class="comment"> *        例如：ABC##D##EF##G## 先序遍历：A-&gt;B-&gt;C-&gt;D-&gt;E-&gt;F-&gt;G 当层次遍历时候</span></span><br><span class="line"><span class="comment"> *        首先是A即根节点，入队然后出队，输出A，判断其左右孩子，左为B不为空，入队，右孩子也不为空，入队</span></span><br><span class="line"><span class="comment"> *        下一轮循环B出队 输出B，然后C、D入队</span></span><br><span class="line"><span class="comment"> *        在下一轮E出队，输出，F、G入队...一次类推</span></span><br><span class="line"><span class="comment"> *        总言之：先入先出，先左后右</span></span><br><span class="line"><span class="comment"> * @param Q </span></span><br><span class="line"><span class="comment"> * @param T </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LevelTraverse</span><span class="params">(QueueNode *Q, TreeNode *T)</span></span><br><span class="line">&#123;</span><br><span class="line">    EnQueue(T, Q);</span><br><span class="line">    <span class="keyword">while</span> (!IsEmpty(Q))</span><br><span class="line">    &#123;</span><br><span class="line">        QueueNode *node = DeQueue(Q);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>,node-&gt;data-&gt;data); <span class="comment">//队的data指针域的数据域</span></span><br><span class="line">        <span class="keyword">if</span>(node-&gt;data-&gt;lchild)</span><br><span class="line">        &#123;</span><br><span class="line">            EnQueue(node-&gt;data-&gt;lchild, Q);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;data-&gt;rchild)</span><br><span class="line">        &#123;</span><br><span class="line">            EnQueue(node-&gt;data-&gt;rchild, Q);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    TreeNode *T;</span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">    QueueNode *Q = InitQueue();</span><br><span class="line">    <span class="comment">// CreateTree(&amp;T, argv[1], &amp;index);</span></span><br><span class="line">    <span class="comment">// char *s = &quot;ABC###D#E##&quot;;</span></span><br><span class="line">    <span class="type">char</span> *s = <span class="string">&quot;ABC##D##EF##G##&quot;</span>;</span><br><span class="line">    CreateTree(&amp;T,s, &amp;index);</span><br><span class="line">    PreOrder(T); <span class="comment">//先序遍历</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    LevelTraverse(Q, T); <span class="comment">//层次遍历</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二叉树非递归遍历"><a href="#二叉树非递归遍历" class="headerlink" title="二叉树非递归遍历"></a>二叉树非递归遍历</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二叉树非递归遍历</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">lchild</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">rchild</span>;</span></span><br><span class="line">    <span class="type">int</span> flag; <span class="comment">//标志符，用于非递归后序遍历：初始化为0，遍历过置1.</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    flag的作用：因为后续遍历是左右中，但是每次压入栈中时候中都会先一步于右压入栈中，它是否弹出输出主要看它的右是否遍历过了，若遍历</span></span><br><span class="line"><span class="comment">    过了的话就直接弹出且输出。非递归后续遍历中会给出详细例子讲解</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;TreeNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    TreeNode *data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;StackNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 二叉树的创建，注意：用二级指针原因是修改了一级指针的内容</span></span><br><span class="line"><span class="comment"> *        根左右的创建方式</span></span><br><span class="line"><span class="comment"> * @param T 二叉树</span></span><br><span class="line"><span class="comment"> * @param data 用于建立二叉树的字符串</span></span><br><span class="line"><span class="comment"> * @param index 用于在递归中记录当前第N个字符</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateTree</span><span class="params">(TreeNode **T, <span class="type">char</span> *data, <span class="type">int</span> *index)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    ch = data[*index];</span><br><span class="line">    *index += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(ch == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        *T = <span class="literal">NULL</span>; <span class="comment">//若为#则为空节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        *T = (TreeNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(TreeNode));</span><br><span class="line">        (*T)-&gt;data = ch;</span><br><span class="line">        (*T)-&gt;flag = <span class="number">0</span>; </span><br><span class="line">        <span class="comment">//根据递归思路知道：它会先创建左边的遇到#然后递归回来在创建右边的</span></span><br><span class="line">        CreateTree(&amp;((*T)-&gt;lchild), data, index); <span class="comment">//创建左子树</span></span><br><span class="line">        CreateTree(&amp;((*T)-&gt;rchild), data, index); <span class="comment">//创建右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 栈的初始化</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @return StackNode* </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">StackNode* <span class="title function_">InitStack</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    StackNode *s = (StackNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(StackNode));</span><br><span class="line">    s-&gt;data = <span class="literal">NULL</span>;</span><br><span class="line">    s-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 入栈操作</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param data </span></span><br><span class="line"><span class="comment"> * @param s </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Push</span><span class="params">(TreeNode *data, StackNode *s)</span></span><br><span class="line">&#123;</span><br><span class="line">    StackNode *node = (StackNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(StackNode));</span><br><span class="line">    node-&gt;data = data;</span><br><span class="line">    node-&gt;next = s-&gt;next;</span><br><span class="line">    s-&gt;next = node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 判断栈空</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param s </span></span><br><span class="line"><span class="comment"> * @return int 1：空 0：非空</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">IsEmpty</span><span class="params">(StackNode *s)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(s-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 出栈操作</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param s </span></span><br><span class="line"><span class="comment"> * @return StackNode* </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">StackNode *<span class="title function_">Pop</span><span class="params">(StackNode *s)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(IsEmpty(s))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        StackNode *node = s-&gt;next;</span><br><span class="line">        s-&gt;next = node-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 非递归先序遍历，下面代码给出详细介绍</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param T </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PreOrder</span><span class="params">(TreeNode *T)</span></span><br><span class="line">&#123;</span><br><span class="line">    TreeNode *node = T;</span><br><span class="line">    StackNode *s = InitStack(); <span class="comment">//建栈对树木的节点压栈</span></span><br><span class="line">    <span class="keyword">while</span>(node || !IsEmpty(s)) <span class="comment">//如果节点非空或者栈非空</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        例如例子 AB##C##先输出了A节点，然后把A节点压入栈中 node指向A的左孩子，进入下一轮循环，继续走if选项，输出之后再次压入栈中,node指向B节点的左孩子，</span></span><br><span class="line"><span class="comment">        但是B节点的左孩子为空，故在下一轮循环中B节点将从栈中弹出，用node接收，访问它的右孩子，此时右孩子也为空，则再次返回，然后将A节点弹出，node接收它</span></span><br><span class="line"><span class="comment">        的右节点也就是C节点，然后输出C节点，再将其压入栈中，发现它的左孩子为空，故将其从栈中弹出，然后访问它右孩子，发现也是空。此时栈中为空且node为空</span></span><br><span class="line"><span class="comment">        故结束本次遍历输出ABC</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span>(node)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>,node-&gt;data);</span><br><span class="line">            Push(node, s);</span><br><span class="line">            node = node-&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            node = Pop(s)-&gt;data;</span><br><span class="line">            node = node-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 非递归中序遍历</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param T </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InOrder</span><span class="params">(TreeNode *T)</span></span><br><span class="line">&#123;</span><br><span class="line">    TreeNode *node = T;</span><br><span class="line">    StackNode *s = InitStack();</span><br><span class="line">    <span class="keyword">while</span>(node || !IsEmpty(s))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        同样拿上面先序遍历例子来说：首先是A节点，先压入栈中，找它左孩子，其左孩子为B节点，B节点在压入栈中，因B节点左孩子为空，则弹出B节点，然后输出B节点的值，</span></span><br><span class="line"><span class="comment">        在看它的右孩子，发现它的右孩子也为空，所以弹出A节点并输出它的值，然后查看它的右孩子，右孩子是C节点不为空，压入栈中，在访问左孩子，但为空，然后弹出栈</span></span><br><span class="line"><span class="comment">        并且直接访问它，然后查看它的右孩子，为空，然后栈空，node为NULL故循环结束，则输出BAC</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span>(node)</span><br><span class="line">        &#123;</span><br><span class="line">            Push(node,s);</span><br><span class="line">            node = node-&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            node = Pop(s)-&gt;data;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>,node-&gt;data);</span><br><span class="line">            node = node-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 获取栈顶（并非弹出栈顶，只是获取），用于非递归后序遍历中使用</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param s </span></span><br><span class="line"><span class="comment"> * @return StackNode* </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">StackNode* <span class="title function_">GetTop</span><span class="params">(StackNode *s)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(IsEmpty(s))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        StackNode *node = s-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 非递归后续遍历</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param T </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PostOrder</span><span class="params">(TreeNode *T)</span></span><br><span class="line">&#123;</span><br><span class="line">    TreeNode *node = T;</span><br><span class="line">    StackNode *s = InitStack();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    不同于先序遍历和中序遍历，后续遍历更为复杂。</span></span><br><span class="line"><span class="comment">    举同上面例子来说明，首先A节点被压入栈中，访问它的左孩子也就是B节点，但B左孩子为空即node为空故走else,发现B节点右孩子为空故继续走嵌套那个else,</span></span><br><span class="line"><span class="comment">    此时B节点弹出用top接收，将其输出，然后B节点的flag标志置1，需要注意的是node还是空的并没有改变，于是继续走第一个else,获取栈顶是A节点,用top接收，</span></span><br><span class="line"><span class="comment">    发现其右孩子C节点不为空，并且它的flag为0，于是将其右孩子C节点压入栈中。node节点指向C节点的左孩子，发现它的左孩子为空,故下个循环先走第一个else，</span></span><br><span class="line"><span class="comment">    然后发现它的右也为空，于是继续走第二个else，弹出栈顶C节点并且输出，另令其标志位置1，注意node此次循环并未改变，于是走下一轮循环时候因node为空走else，</span></span><br><span class="line"><span class="comment">    获取它栈顶节点A，它的右孩子不为空但是它的右孩子标志位已经置1，于是走第二个else弹出A节点，输出，然后令A节点标志位置1，此时node还是为空，且栈为空故</span></span><br><span class="line"><span class="comment">    结束循环</span></span><br><span class="line"><span class="comment">    又如：ABC##D#E##F##</span></span><br><span class="line"><span class="comment">    例子流程：A入栈--&gt;B入栈--&gt;C入栈--&gt;C左孩子为空走else，栈顶为C，右孩子为空接着走else，弹出C节点输出C,且标志位置1--&gt;</span></span><br><span class="line"><span class="comment">    node还是为空继续走else,获取栈顶B，有右孩子D节点且标志位为0，将D压入栈中,node找它的左孩子为空--&gt;node空走else，获取栈顶D节点，D节点</span></span><br><span class="line"><span class="comment">    有右孩子E节点且标志位为0，将E节点压入栈中,E节点左孩子为空，即node为空--&gt;node空走else，获取栈顶E节点，为空不符合，再走else弹出栈顶E节点</span></span><br><span class="line"><span class="comment">    输出且另其标志位置1--&gt;node没变化还是空，继续走else,获取栈顶节点D，其有右孩子且右孩子标志位为1，故走else节点D弹出栈输出且将其标志位置1，</span></span><br><span class="line"><span class="comment">    --&gt;node依旧没变还是空，走else获取栈顶B节点，因其右孩子E标志已经置1，故走弹出B节点并输出置1--&gt;node依旧没变，故这次循环依旧获取栈顶A节点，</span></span><br><span class="line"><span class="comment">    有右孩子（F节点）且没遍历过（flag==0），故将F节点压入栈中,node指向F的左孩子，但为空--&gt;因node为空，这次循环依旧获取栈顶F节点，没孩子故走</span></span><br><span class="line"><span class="comment">    else弹出节点F，输出然后置1--&gt;node依旧为空这次循环走else获取栈顶A节点，有右孩子但遍历过，故直接弹出A节点输出然后置为1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">while</span>(node || !IsEmpty(s))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(node) <span class="comment">//一样找到最左的树节点</span></span><br><span class="line">        &#123;</span><br><span class="line">            Push(node, s);</span><br><span class="line">            node = node-&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode *top = GetTop(s)-&gt;data; <span class="comment">//获取栈顶</span></span><br><span class="line">            <span class="keyword">if</span>(top-&gt;rchild &amp;&amp; top-&gt;rchild-&gt;flag == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                top = top-&gt;rchild;</span><br><span class="line">                Push(top,s);</span><br><span class="line">                node = top-&gt;lchild;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                top = Pop(s)-&gt;data;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>,top-&gt;data);</span><br><span class="line">                top-&gt;flag = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    TreeNode *T;</span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//修改一级指针传其地址上述用二级指针接收，传第一个命令行参数的字符串</span></span><br><span class="line">    <span class="comment">// CreateTree(&amp;T, argv[1], &amp;index); </span></span><br><span class="line">    <span class="comment">// char *s = &quot;AB##C##&quot;; //根A 左B 右C</span></span><br><span class="line">    <span class="type">char</span> *s = <span class="string">&quot;ABC##D#E##F##&quot;</span>;</span><br><span class="line">    CreateTree(&amp;T, s, &amp;index);</span><br><span class="line">    PreOrder(T);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    InOrder(T);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    PostOrder(T);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h2><p><em>前驱节点：对一棵二叉树进行中序遍历，遍历后的顺序，当前节点的前一个节点为该节点的前驱节点；</em></p>
<p><em>后继节点：对一棵二叉树进行中序遍历，遍历后的顺序，当前节点的后一个节点为该节点的后继节点；</em></p>
<p><em>例如一颗完全二叉树（1,2,3,4,5,6,7），按照中序遍历后的顺序为：（4,2,5,1,6,3,7），1节点的前驱节点为：5，后继节点为6.</em></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/hpcds/article/details/88706413">参考链接</a></p>
<p><em>如果节点有左孩子，那么Lchild依然指向他的左孩子，否则指向遍历序列中他的前驱节点。</em></p>
<p><em>如果节点有右孩子，那么Rchild依然指向他的左孩子，否则指向遍历序列中他的后继节点。</em></p>
<p><em>Ltag和Rtag的定义如下:</em></p>
<p><em>Ltag : 等于0时，Lchild域指示节点的左孩子;等于1时，Lchild指示节点的遍历前驱。</em></p>
<p><em>Rtag : 等于0时，Rchild域指示节点的左孩子;等于1时，Rchild指示节点的遍历后继。</em></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/kcycxy/article/details/109729998">参考链接</a></p>
<h3 id="中序线索二叉树"><a href="#中序线索二叉树" class="headerlink" title="中序线索二叉树"></a>中序线索二叉树</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">char</span> data;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">lchild</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">rchild</span>;</span></span><br><span class="line">  <span class="type">int</span> ltag;</span><br><span class="line">  <span class="type">int</span> rtag;</span><br><span class="line">&#125;TreeNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 创建二叉树</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param T </span></span><br><span class="line"><span class="comment"> * @param data </span></span><br><span class="line"><span class="comment"> * @param idnex </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateTree</span><span class="params">(TreeNode **T, <span class="type">char</span> *data, <span class="type">int</span> *index)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> ch;</span><br><span class="line">  ch =data[*index];</span><br><span class="line">  *index += <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(ch == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    *T = <span class="literal">NULL</span>; <span class="comment">//#代表空节点</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    *T = (TreeNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(TreeNode));</span><br><span class="line">    (*T)-&gt;data = ch;</span><br><span class="line">    (*T)-&gt;ltag = <span class="number">0</span>;</span><br><span class="line">    (*T)-&gt;rtag = <span class="number">0</span>;</span><br><span class="line">    CreateTree(&amp;((*T)-&gt;lchild), data, index); <span class="comment">//创建左子树</span></span><br><span class="line">    CreateTree(&amp;((*T)-&gt;rchild), data, index); <span class="comment">//创建右子树</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 中序遍历：简言之：先处理左孩子-&gt;办事-&gt;处理右孩子 左-&gt;中-&gt;右</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param T</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InOrder</span><span class="params">(TreeNode* T)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        InOrder(T-&gt;lchild); <span class="comment">//打印左孩子</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, T-&gt;data);</span><br><span class="line">        InOrder(T-&gt;rchild); <span class="comment">//最后打印右孩子</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 中序线索二叉树 </span></span><br><span class="line"><span class="comment">*        *pre一直指向T之前指向的那个，前驱的话就是T-&gt;left=*pre，后继是*p-&gt;right = T</span></span><br><span class="line"><span class="comment"> * @param T </span></span><br><span class="line"><span class="comment"> * @param pre 始终指向刚刚访问过的节点 也可以定义一个全局一级指针变量的pre</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InThreadTree</span><span class="params">(TreeNode *T, TreeNode **pre)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(T)</span><br><span class="line">  &#123;</span><br><span class="line">    InThreadTree(T-&gt;lchild, pre); <span class="comment">//递归左子树线索化</span></span><br><span class="line">    <span class="keyword">if</span>(T-&gt;lchild == <span class="literal">NULL</span>) <span class="comment">//没有左孩子</span></span><br><span class="line">    &#123;</span><br><span class="line">      T-&gt;ltag = <span class="number">1</span>; <span class="comment">//前驱线索</span></span><br><span class="line">      T-&gt;lchild = *pre; <span class="comment">//左孩子的指针指向前驱</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(*pre != <span class="literal">NULL</span> &amp;&amp; (*pre)-&gt;rchild == <span class="literal">NULL</span>) <span class="comment">//前驱不为空，且没有右孩子</span></span><br><span class="line">    &#123;</span><br><span class="line">      (*pre)-&gt;rtag = <span class="number">1</span>; <span class="comment">//后继线索</span></span><br><span class="line">      (*pre)-&gt;rchild = T; <span class="comment">//前驱的右孩子指向后继，当前节点T</span></span><br><span class="line">    &#125;</span><br><span class="line">    *pre = T;</span><br><span class="line">    InThreadTree(T-&gt;rchild, pre); <span class="comment">//递归右子树的线索化</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 获取第一个值：线索化之后最左的那个节点（左孩子为空）肯定指向了它的前驱</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param T </span></span><br><span class="line"><span class="comment"> * @return TreeNode* </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">TreeNode* <span class="title function_">GetFirst</span><span class="params">(TreeNode *T)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">while</span>(T-&gt;ltag == <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    T = T-&gt;lchild;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Get the Next object</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param node </span></span><br><span class="line"><span class="comment"> * @return TreeNode* </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">TreeNode *<span class="title function_">GetNext</span><span class="params">(TreeNode *node)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  举例：AB#C##D## 中序遍历为BCAD且B节点左孩子为空，C节点左右孩子都空，D左右孩子都空 </span></span><br><span class="line"><span class="comment">  所以B节点左孩子指向它的前驱，没有即NULL，C的左指向B，C的右指向A   D的左指向A，D的右指向NULL</span></span><br><span class="line"><span class="comment">  线索化后，查找该节点的下一个即：找到右孩子指向了后继的节点</span></span><br><span class="line"><span class="comment">  如：假设找B节点的下一个：因为它的rtag == 0即还有右孩子，故找它的右孩子C节点作为根节点的最左的那个值，因为没有左孩子，故直接返回，也就是返回了C节点</span></span><br><span class="line"><span class="comment">  再找C的下一个节点，它的右指向了后继A，也就是rtag==1，故直接返回它的后继A节点， 再找A节点的下一个，有右孩子走else，找以D为根节点的树最左的那个，这里</span></span><br><span class="line"><span class="comment">  也就是它自己，故将D节点返回，再找D节点下一个发现为空NULL--也就是遍历完成了</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">if</span>(node -&gt;rtag == <span class="number">1</span>) </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> node-&gt;rchild;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> GetFirst(node-&gt;rchild);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InThreadTreePrint</span><span class="params">(TreeNode *T)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span>(TreeNode *node = GetFirst(T);node != <span class="literal">NULL</span>;node = GetNext(node))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>,node-&gt;data);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">  TreeNode *T;</span><br><span class="line">  TreeNode *pre = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// CreateTree(&amp;T, argv[1], &amp;index);</span></span><br><span class="line">  <span class="type">char</span> *s = <span class="string">&quot;AB#C##D##&quot;</span>;</span><br><span class="line">  CreateTree(&amp;T, s, &amp;index);</span><br><span class="line">  InOrder(T);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">  InThreadTree(T, &amp;pre);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,pre-&gt;data);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  <span class="comment">//pre已经指向最后一个节点，另其右孩子指向为空，这样Next函数遍历到它时候可直返回其右节点即NULL</span></span><br><span class="line">  pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">  pre-&gt;rchild = <span class="literal">NULL</span>; </span><br><span class="line">  InThreadTreePrint(T);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="先序线索二叉树"><a href="#先序线索二叉树" class="headerlink" title="先序线索二叉树"></a>先序线索二叉树</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//先序线索二叉树 类似于中序线索二叉树，只不过指针指向的是先序遍历的前驱和后继</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">lchild</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">rchild</span>;</span></span><br><span class="line">    <span class="type">int</span> ltag;</span><br><span class="line">    <span class="type">int</span> rtag;</span><br><span class="line">&#125;TreeNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 创建二叉树</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param T </span></span><br><span class="line"><span class="comment"> * @param data </span></span><br><span class="line"><span class="comment"> * @param idnex </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateTree</span><span class="params">(TreeNode **T, <span class="type">char</span> *data, <span class="type">int</span> *index)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    ch =data[*index];</span><br><span class="line">    *index += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(ch == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        *T = <span class="literal">NULL</span>; <span class="comment">//#代表空节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        *T = (TreeNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(TreeNode));</span><br><span class="line">        (*T)-&gt;data = ch;</span><br><span class="line">        (*T)-&gt;ltag = <span class="number">0</span>;</span><br><span class="line">        (*T)-&gt;rtag = <span class="number">0</span>;</span><br><span class="line">        CreateTree(&amp;((*T)-&gt;lchild), data, index); <span class="comment">//创建左子树</span></span><br><span class="line">        CreateTree(&amp;((*T)-&gt;rchild), data, index); <span class="comment">//创建右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 先序线索二叉树线索化</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param T 当前节点</span></span><br><span class="line"><span class="comment"> * @param pre T的前一节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PreThreadTree</span><span class="params">(TreeNode *T, TreeNode **pre)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(T)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(T-&gt;lchild == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            T-&gt;ltag = <span class="number">1</span>;</span><br><span class="line">            T-&gt;lchild = *pre;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(*pre != <span class="literal">NULL</span> &amp;&amp; (*pre)-&gt;rchild == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            (*pre)-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">            (*pre)-&gt;rchild = T;</span><br><span class="line">        &#125;</span><br><span class="line">        *pre = T;</span><br><span class="line">        <span class="keyword">if</span>(T-&gt;ltag == <span class="number">0</span>) <span class="comment">//这里不同于中序遍历，需要先考虑是否有左孩子，假设不考虑，当遍历到最左那个孩子时候，左孩子已经指向了它的前驱，若再将它的左孩子进行递归则会出错</span></span><br><span class="line">        &#123;              </span><br><span class="line">            PreThreadTree(T-&gt;lchild, pre);</span><br><span class="line">        &#125;</span><br><span class="line">        PreThreadTree(T-&gt;rchild, pre);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 获取下一个节点</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param node </span></span><br><span class="line"><span class="comment"> * @return TreeNode* </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">TreeNode *<span class="title function_">GetNext</span><span class="params">(TreeNode *node)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//node-&gt;rtag==1:没有右孩子（已经线索化），即直接指向它的后继  node-&gt;ltag==1:没有左孩子</span></span><br><span class="line">    <span class="keyword">if</span>(node-&gt;ltag == <span class="number">1</span> || node-&gt;rtag == <span class="number">1</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> node-&gt;rchild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> node-&gt;lchild;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 输出先序线索二叉树</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param T </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PreThreadTreePrint</span><span class="params">(TreeNode *T)</span></span><br><span class="line">&#123;</span><br><span class="line">    TreeNode *node = T;</span><br><span class="line">    <span class="keyword">for</span>(;node != <span class="literal">NULL</span>; node = GetNext(node))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>,node-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    TreeNode *T;</span><br><span class="line">    TreeNode *pre = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// CreateTree(&amp;T, argv[1], &amp;index);</span></span><br><span class="line">    <span class="type">char</span> *s = <span class="string">&quot;AB#C##D##&quot;</span>;</span><br><span class="line">    CreateTree(&amp;T, s, &amp;index);</span><br><span class="line">    PreThreadTree(T, &amp;pre);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,pre-&gt;data);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="comment">//pre已经指向最后一个节点，另其右孩子指向为空，这样Next函数遍历到它时候可直返回其右节点即NULL</span></span><br><span class="line">    pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">    pre-&gt;rchild = <span class="literal">NULL</span>; </span><br><span class="line">    PreThreadTreePrint(T);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="后续线索二叉树"><a href="#后续线索二叉树" class="headerlink" title="后续线索二叉树"></a>后续线索二叉树</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//后续线索二叉树，前驱和后继指的是后续遍历的前驱后继</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">lchild</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">rchild</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">parent</span>;</span> <span class="comment">//记录该节点父节点</span></span><br><span class="line">    <span class="type">int</span> ltag;</span><br><span class="line">    <span class="type">int</span> rtag;</span><br><span class="line">&#125;TreeNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 创建二叉树</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param T </span></span><br><span class="line"><span class="comment"> * @param data </span></span><br><span class="line"><span class="comment"> * @param idnex </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreateTree</span><span class="params">(TreeNode **T, <span class="type">char</span> *data, <span class="type">int</span> *index, TreeNode *parent)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    ch =data[*index];</span><br><span class="line">    *index += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(ch == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        *T = <span class="literal">NULL</span>; <span class="comment">//#代表空节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        *T = (TreeNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(TreeNode));</span><br><span class="line">        (*T)-&gt;data = ch;</span><br><span class="line">        (*T)-&gt;ltag = <span class="number">0</span>;</span><br><span class="line">        (*T)-&gt;rtag = <span class="number">0</span>;</span><br><span class="line">        (*T)-&gt;parent = parent;</span><br><span class="line">        CreateTree(&amp;((*T)-&gt;lchild), data, index, *T); <span class="comment">//创建左子树</span></span><br><span class="line">        CreateTree(&amp;((*T)-&gt;rchild), data, index, *T); <span class="comment">//创建右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 后续线索二叉树线索化</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param T 当前节点</span></span><br><span class="line"><span class="comment"> * @param pre T的前一节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PostThreadTree</span><span class="params">(TreeNode *T, TreeNode **pre)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(T)</span><br><span class="line">    &#123;</span><br><span class="line">        PostThreadTree(T-&gt;lchild, pre);</span><br><span class="line">        PostThreadTree(T-&gt;rchild, pre);</span><br><span class="line">        <span class="keyword">if</span>(T-&gt;lchild == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            T-&gt;ltag = <span class="number">1</span>;</span><br><span class="line">            T-&gt;lchild = *pre;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(*pre != <span class="literal">NULL</span> &amp;&amp; (*pre)-&gt;rchild == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            (*pre)-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">            (*pre)-&gt;rchild = T;</span><br><span class="line">        &#125;</span><br><span class="line">        *pre = T;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">TreeNode *<span class="title function_">GetFirst</span><span class="params">(TreeNode *T)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//找寻第一个节点需要考虑最左边的节点有没有右孩子，若没有右孩子则它就是第一个节点，若有则以右子树节点为根继续寻找最左节点</span></span><br><span class="line">    <span class="keyword">while</span>(T-&gt;ltag == <span class="number">0</span>) <span class="comment">//先找到最左孩子</span></span><br><span class="line">    &#123;</span><br><span class="line">        T = T-&gt;lchild; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(T-&gt;rtag == <span class="number">0</span>) <span class="comment">//如果有右孩子则以其右孩子为根寻找最左边孩子</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> GetFirst(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 获取下一个节点</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param node </span></span><br><span class="line"><span class="comment"> * @return TreeNode* </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">TreeNode *<span class="title function_">GetNext</span><span class="params">(TreeNode *node)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(node-&gt;rtag == <span class="number">1</span>) <span class="comment">//说明已经线索化，则其右孩子指向它的后继，也就是下一个节点</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> node-&gt;rchild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    1.现在节点时根节点，则next = NULL</span></span><br><span class="line"><span class="comment">    2.是左孩子，那么判断父亲是否有右孩子，若没有则next = 父亲节点；若有则next = GetFirst(父亲节点-&gt;rchild)</span></span><br><span class="line"><span class="comment">    3.若为右，则next = 父亲节点</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果是根节点</span></span><br><span class="line">        <span class="keyword">if</span>(node-&gt;parent == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果是右孩子:它父亲的右孩子是它自己，此时返回它父亲</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(node-&gt;parent-&gt;rchild == node)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> node-&gt;parent;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//左孩子</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;parent-&gt;rtag == <span class="number">0</span>) <span class="comment">//如果父亲右子树不为空，则以父亲的右子树为根节点找到第一个节点</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> GetFirst(node-&gt;parent-&gt;rchild);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">//若为空则返回它的父亲</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> node-&gt;parent;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 输出后序线索二叉树</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param T </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PostThreadTreePrint</span><span class="params">(TreeNode *T)</span></span><br><span class="line">&#123;</span><br><span class="line">    TreeNode *node = GetFirst(T);</span><br><span class="line">    <span class="keyword">for</span>(;node != <span class="literal">NULL</span>; node = GetNext(node))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>,node-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    TreeNode *T;</span><br><span class="line">    TreeNode *pre = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// CreateTree(&amp;T, argv[1], &amp;index);</span></span><br><span class="line">    <span class="type">char</span> *s = <span class="string">&quot;AB#C##D##&quot;</span>;</span><br><span class="line">    CreateTree(&amp;T, s, &amp;index, <span class="literal">NULL</span>);</span><br><span class="line">    PostThreadTree(T, &amp;pre);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,pre-&gt;data);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="comment">//pre已经指向最后一个节点，另其右孩子指向为空，这样Next函数遍历到它时候可直返回其右节点即NULL</span></span><br><span class="line">    <span class="comment">// pre-&gt;rtag = 1;</span></span><br><span class="line">    <span class="comment">// pre-&gt;rchild = NULL;  //后序遍历中最后一个节点时根节点，它有左右孩子，不能对他进行修改</span></span><br><span class="line">    PostThreadTreePrint(T);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Acy</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://example.com/2022/05/10/struct_data/">http://example.com/2022/05/10/struct_data/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/lcjyl/images/img/structdata.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2022/04/16/python_base/"><img class="next-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">Python的一些基础与语法</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://avatars.githubusercontent.com/u/82205323?s=400&amp;u=3b0d8385b46a33a5401767ff455bf0e935801a41&amp;v=4" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Acy</div><div class="author-info__description"></div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">3</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">0</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">1</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://www.4399.com"><i class="fab fa-github"></i><span>Don't click Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">Study hard for love</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8"><span class="toc-number">1.</span> <span class="toc-text">链表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8"><span class="toc-number">1.1.</span> <span class="toc-text">单链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8"><span class="toc-number">1.2.</span> <span class="toc-text">单循环链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E9%93%BE%E8%A1%A8"><span class="toc-number">1.3.</span> <span class="toc-text">双链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8"><span class="toc-number">1.4.</span> <span class="toc-text">双循环链表</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%88"><span class="toc-number">2.</span> <span class="toc-text">栈</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%98%9F%E5%88%97"><span class="toc-number">3.</span> <span class="toc-text">队列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%9E%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97"><span class="toc-number">3.1.</span> <span class="toc-text">非循环队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97"><span class="toc-number">3.2.</span> <span class="toc-text">循环队列</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D"><span class="toc-number">4.</span> <span class="toc-text">字符串匹配</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E5%8C%B9%E9%85%8D"><span class="toc-number">4.1.</span> <span class="toc-text">直接匹配</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#KMP%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.2.</span> <span class="toc-text">KMP算法实现</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">5.</span> <span class="toc-text">二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">5.1.</span> <span class="toc-text">二叉树的创建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86"><span class="toc-number">5.2.</span> <span class="toc-text">二叉树的层次遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E9%9D%9E%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86"><span class="toc-number">5.3.</span> <span class="toc-text">二叉树非递归遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">5.4.</span> <span class="toc-text">线索二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E5%BA%8F%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">5.4.1.</span> <span class="toc-text">中序线索二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%88%E5%BA%8F%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">5.4.2.</span> <span class="toc-text">先序线索二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8E%E7%BB%AD%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">5.4.3.</span> <span class="toc-text">后续线索二叉树</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/05/10/struct_data/" title="数据结构（C）"><img src="https://cdn.jsdelivr.net/gh/lcjyl/images/img/structdata.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数据结构（C）"/></a><div class="content"><a class="title" href="/2022/05/10/struct_data/" title="数据结构（C）">数据结构（C）</a><time datetime="2022-05-10T04:51:04.130Z" title="Created 2022-05-10 12:51:04">2022-05-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/04/16/python_base/" title="Python的一些基础与语法"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Python的一些基础与语法"/></a><div class="content"><a class="title" href="/2022/04/16/python_base/" title="Python的一些基础与语法">Python的一些基础与语法</a><time datetime="2022-04-16T09:37:30.524Z" title="Created 2022-04-16 17:37:30">2022-04-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/04/10/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E5%8E%9F%E7%90%86%E7%AC%AC%E4%B8%80%E7%AB%A0/" title="自动控制原理（第一章）"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="自动控制原理（第一章）"/></a><div class="content"><a class="title" href="/2022/04/10/%E8%87%AA%E5%8A%A8%E6%8E%A7%E5%88%B6%E5%8E%9F%E7%90%86%E7%AC%AC%E4%B8%80%E7%AB%A0/" title="自动控制原理（第一章）">自动控制原理（第一章）</a><time datetime="2022-04-10T08:52:36.348Z" title="Created 2022-04-10 16:52:36">2022-04-10</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://cdn.jsdelivr.net/gh/lcjyl/images/img/structdata.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By Acy</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="Switch Between Traditional Chinese And Simplified Chinese">简体</button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="true"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>